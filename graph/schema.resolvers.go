package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"fmt"
	"io"
	//"log"
	"math/rand"
	"os"
	"path/filepath"
	"time"
	postgres "videoApi/graph/connection"
	"videoApi/graph/model"

	"github.com/99designs/gqlgen/graphql"
)

// CreateVideo is the resolver for the createVideo field.
func (r *mutationResolver) CreateVideo(ctx context.Context, input model.NewVideo) (*model.Video, error) {
	//panic(fmt.Errorf("not implemented: CreateVideo - createVideo"))

	conn := postgres.DB
	res := model.Video{
		Name:   input.Name,
		URL:    input.URL,
		Author: input.Author,
	}

	err := conn.Create(&res).Error

	if err!=nil{
		return nil,err
	}

	fmt.Println("data inserted successfully")

	return &res, nil
}

// UpdateVideo is the resolver for the updateVideo field.
func (r *mutationResolver) UpdateVideo(ctx context.Context, input model.UpdateVideo) (*model.Video, error) {
	//panic(fmt.Errorf("not implemented: UpdateVideo - updateVideo"))
	conn := postgres.DB

	var vid model.Video

	err := conn.First(&vid, input.ID).Error
	if err != nil {
		return nil, err
	}

	if input.Name != "" {
		vid.Name = input.Name
	}

	if input.URL != "" {
		vid.URL = input.URL
	}
	
	if input.Author != nil {
		vid.Author = *input.Author
	}

	// Save the updated video back to the database
	if err := conn.Save(&vid).Error; err != nil {
		return nil, err
	}
	return &vid, err
}

// RemoveVideo is the resolver for the removeVideo field.
func (r *mutationResolver) RemoveVideo(ctx context.Context, input model.DeleteVideo) (string, error) {
	//panic(fmt.Errorf("not implemented: RemoveVideo - removeVideo"))
	conn := postgres.DB
	res := model.Video{
		ID: input.ID,
	}

	err := conn.Delete(&res).Error
	if err != nil {
		// Handle the error, e.g., return an error response.
		return "data not deleted", err
	}

	return "data deleted", nil
}

// UploadFile is the resolver for the uploadFile field.

func (r *mutationResolver) UploadFile(ctx context.Context, file graphql.Upload) (string, error) {
	// Ensure the file is closed after the function returns.
	//defer file.File.Close()
	// You can access the uploaded file using file.File.
	uploadedFile := file.File

	// Extract the original filename from the uploaded file.
	// You can customize this to generate a unique name.
	originalFilename := file.Filename

	// Remove any potentially unsafe characters from the filename to prevent directory traversal.
	sanitizedFilename := filepath.Base(originalFilename)

	// Specify the directory where you want to save the uploaded files (e.g., "uploads").
	uploadDir := "./Documents"

	// Ensure the upload directory exists, create it if not.
	if err := os.MkdirAll(uploadDir, os.ModePerm); err != nil {
		return "", err
	}

	// Generate a unique filename by appending a timestamp and a random number to the sanitized filename.
	timestamp := time.Now().Format("20060102150405")
	uniqueFileName := fmt.Sprintf("%s_%s_%d", sanitizedFilename, timestamp, rand.Intn(10000))

	// Create a file on the server to save the uploaded content.
	filePath := filepath.Join(uploadDir, uniqueFileName)
	newFile, err := os.Create(filePath)
	if err != nil {
		return "", err
	}
	defer newFile.Close()

	// Copy the content of the uploaded file to the new file.
	_, err = io.Copy(newFile, uploadedFile)
	if err != nil {
		return "", err
	}

	return "File uploaded successfully", nil
}

// Videos is the resolver for the videos field.
func (r *queryResolver) Videos(ctx context.Context) ([]*model.Video, error) {
	// panic(fmt.Errorf("not implemented: Videos - videos"))

	conn := postgres.DB

	var vdo []*model.Video

	err := conn.Find(&vdo).Error

	if err != nil {
		// Handle the error, e.g., return an error response.
		return nil, err
	}

	return vdo, nil
}

// Videoid is the resolver for the videoid field.
func (r *queryResolver) Videoid(ctx context.Context, id int) (*model.Video, error) {
	//panic(fmt.Errorf("not implemented: Videoid - videoid"))
	conn := postgres.DB
	var vdo model.Video

	err := conn.First(&vdo, id).Error
	if err != nil {
		return nil, err
	}

	return &vdo, err
}

// Videoname is the resolver for the videoname field.
func (r *queryResolver) Videoname(ctx context.Context, name *string) ([]*model.Video, error) {
	//panic(fmt.Errorf("not implemented: Videoname - videoname"))

	conn := postgres.DB
	var vdo []*model.Video
	res := &model.Video{
		Name: *name,
	}
	err := conn.Find(&vdo, res).Error

	if err != nil {
		return nil, err
	}

	return vdo, err
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
